module game_miniRegfile (      // regfile has two read ports and one write port
    input clk,                 // clock
    input rst,                 // reset
    input write_address[4],    // write address for port c
    input we,                  // write enable
    input data[16],            // data in for port c
    
    input read_address_a[4],   // address port a 
    input read_address_b[4],   // address port b
    output out_a[16],          // read port a
    output out_b[16],          // read port b
    output literal[16],        // for 7 seg 
    output is_p1[1]
  
  ) {  
  
  .clk(clk){
    .rst(rst){
      dff p1_sequence[16];
      dff p2_sequence[16];
      dff sequence_count[16];
      dff p1_score[5];
      dff p2_score[5];
      dff round[8];
      dff is_p1[1];
      dff literal_out[16];
      dff loop_var[5];
    }
  }
  
  always {   
    
    // read port a
    case(read_address_a) {
        b0000 : out_a = p1_sequence.q;    // stores the player 1 sequence value
        b0001 : out_a = p2_sequence.q;    // stores the player 2 sequence value
        b0010 : out_a = sequence_count;   // stores the current button sequence count
        b0011 : out_a = p1_score;         // stores player 1's current score
        b0100 : out_a = p2_score;         // stores player 2's current score
        b0101 : out_a = round;            // stores the current round
        b0110 : out_a = is_p1;            // checks if the current player is player 1
        b0111 : out_a = temp_var1;          
        b1000 : out_a = temp_var2;    
        b1001 : out_a = loop_var;
        b1010 : out_a = literal_out[16];
      
    }
    
    // read port b
    case(read_address_b) {
        b0000 : out_b = p1_sequence.q;    // stores the player 1 sequence value
        b0001 : out_b = p2_sequence.q;    // stores the player 2 sequence value
        b0010 : out_b = sequence_count;   // stores the current button sequence count
        b0011 : out_b = p1_score;         // stores player 1's current score
        b0100 : out_b = p2_score;         // stores player 2's current score
        b0101 : out_b = round;            // stores the current round
        b0110 : out_b = is_p1;            // checks if the current player is player 1
        b0111 : out_b = temp_var1;        // 
        b1000 : out_b = temp_var2;        // 
        b1001 : out_b = loop_var;        // 
        b1010 : out_b = literal_out;  
        default: out_b = 0;
    }
    
    // write port
    if (we){
      case(write_address) {
        b0000 : p1_sequence.d = data; 
        b0001 : p2_sequence.d = data; 
        b0010 : sequence_count.d = data; 
        b0011 : p1_score.d = data; 
        b0100 : p2_score.d = data; 
        b0101 : round.d = data; 
        b0110 : is_p1.d = data; 
        b0111 : temp_var1.d = data;
        b1000 : temp_var2.d = data;
        b1001 : loop_var.d = data;
        b1010 : literal_out.d = data;
      }
    }    
    literal = literal_out.q;
    is_p1 = is_p1.q;
    }
}