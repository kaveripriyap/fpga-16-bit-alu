module game_CU ( // game control unit
    input clk,  // clock
    input rst,  // reset
    
    input rbData[16],
    output we,
    output ra[4],
    output rb[4],
    output rc[4],
    output asel[3],
    output bsel[2],
    output wdsel[2],
    output alufn[6],
    input player_button1,
    input player_button2,
    input reset_button,
    output green_led,
    output red_led,
    output split_yes, 
    output split_choice[16]; 
  ) {
  
  .clk(clk){
  
  dff timer[16];
  fsm game_fsm={
    START,
    IDLE,
    PLAYER1_PRESS,
    PLAYER2_PRESS,
    INCREMENT_SEQUENCECOUNT,
    CPMLEQ_SEQUENCECOUNT_1, 
    NOT_ISP1,
    CMPEQ_P1SEQUENCE_P2SEQUENCE,
    UPDATE_LED_GREEN,
    UPDATE_LED_RED,
    TURN_LED_OFF,
    CPMLE_SEQUENCECOUNT_16,
    CMPEQ_ISP1_0,
    INCREMENT_P1_SCORE,
    INCREMENT_P1_SCORE_CMP,
    INCREMENT_P2_SCORE_CMP,
    INCREMENT_P2_SCORE,
    INCREMENT_ROUND,
    CMPLEQC_ROUND_5,
    RESET_SEQUENCE_COUNT,
    TURN_LED_OFF1,
    CMPLEQ_P1_SCORE_P2SCORE,
    CMPEQ_P1_SCORE_P2SCORE,
    P1_WINNER,
    P2_WINNER,
    TIE,
    SET_ISP1_1,
    END
        
  };
}

  var i ;
  always {
  
    //initial values for all the components in the beta, it is changed according to the FSM
    alufn = b111111; // CHANGE
    asel = b000;
    bsel = b00;
    we = b0000;
    ra = b0000;
    rb = b0000;
    rc = b0000;
    wdsel = b0;
    green_led = b0 ;
    red_led = b0; 
    split_yes = 0;

   // timer.d = 0; //initial value input into the timer, can be changed later
   // if (rst){
      // default values assigned above are left as it is,
    //}
    //else{
      case(game_fsm.q){
            
        game_fsm.START: // control unit starts here 
          alufn = b0100; // alufn for  "Y" - passes value of 1 
          bsel = b010; // SEXT(1)

          rc =  b0110; // writes 1 to isP1 register  
          we =1;

          game_fsm.d = game_fsm.CLEAR;


          
        game_fsm.IDLE: // CHECK ISP1=1
          alufn = b0011; // alufn for 'X'
          asel = b00; 

          ra = b0110; // isP1 register
          rc = b0111; //store value in temp register 1

          we=1;

          if (rc.q==1) {                               // checks value of isP1 stored in rc
            game_fsm.d = game_fsm.PLAYER1_PRESS;
          }
          else{
            game_fsm.d = game_fsm.PLAYER2_PRESS;
          }
          
          
        game_fsm.PLAYER1_PRESS: //loops till player  1 presses button the number of times speciified in sequence count
         

         
          for( i=0; i< rc.q ; )
            if button1 pressed
              Px_sequence[i] = 0
            if button2 pressed 
              Px_sequence[i] = 1
}

          game_fsm.d = game_fsm.INCREMENT_SEQUENCECOUNT;

            
        game_fsm.PLAYER2_PRESS: //  //loops till player  1 presses button the number of times speciified in sequence count
          //for loop to store p1_sequence
          
          game_fsm.d = game_fsm.INCREMENT_SEQUENCECOUNT;


        game_fsm.INCREMENT_SEQUENCECOUNT: // incrementing sequence count after a press
          alufn = 6b000000; //ADDC
          asel = b00 ; // register of sequence count 
          bsel = b010 ; //SEXT(1)

          ra = b0010; // register that stores sequence count 
          rc = b0010;  // add 1 to sequence count and write to same register
          we = 1;  

          game_fsm.d = game_fsm.CPMLEQ_SEQUENCECOUNT_1;

                

          
        game_fsm.CPMLEQ_SEQUENCECOUNT_1: // checks if sequence count is less than or equal to 1 
          alufn = b011010; //COMPLEQ
          asel = b00; // passes register ra value
          bsel = b010; // passes SEXT(1)

          ra= b0010; // sequence count register
          rc= b0111 ; // temp register 1
          we = b1;
        
          
          if (rc.q == 1) {
            game_fsm.d = game_fsm.NOT_ISP1;
          }
          else{
            game_fsm.d = game_fsm.CMPEQ_P1SEQUENCE_P2SEQUENCE;
          }


          ]
          
        
        game_fsm.NOT_ISP1: // CONVERTS P1 TO  0 if P1 is 1
          alufn = b1011 ; // NOT_ISP1
          asel = b00; //pass register ra value
          ra = b0110 ; // isP1 register
          
          rc=  b0110;// store result in isP1
          we = 1;
          
          game_fsm.d = game_fsm.IDLE;
                 

        game_fsm.CMPEQ_P1SEQUENCE_P2SEQUENCE: //  compares sequences of the two players to see if they are equal
          //TODO : NEED TO SLICE 
          //CHECK ISP1 and compare accordingly 
          alufn =  b110010 ; //COMPEQ

          asel = b00; //passes ra register
          bsel = b000; //passes rb register

          ra= b0000;
          rb = b0001; 
          rc =  b1000; // store result in temp register 2
          we = 1;

          if(rc.q == 1)
            game_fsm.d = game_fsm.UPDATE_LED_GREEN;
          else
            game_fsm.d = game_fsm.UPDATE_LED_RED;

          
        game_fsm.UPDATE_LED_GREEN: // Led turns green if sequence is equal
          //  ADD STATEMENTS FOR LED

          green_led = b1;
          game_fsm.d = game_fsm.CPMLE_SEQUENCECOUNT_16;
          
        game_fsm.UPDATE_LED_RED: //Led turns Red if sequence is wrong
          // ADD STATEMENTS FOR LED
          red_led = b1;
          game_fsm.d = game_fsm.CMPEQ_ISP1_0;

          
        game_fsm.CPMLE_SEQUENCECOUNT_16: // to check if sequence count is less than 16 
          alufn =  b110110; //COMPLE
          asel = b00; //passes ra register
          bsel = b100; // passes SEXT(16)
          ra=  b0010; 
          
          rc=  b1000; // store in temp register 2
          we= 1;
          if (rc.q == b1){
            game_fsm.d = game_fsm.NOT_ISP1_CMP;

          }
          else{

            game_fsm.d = game_fsm.INCREMENT_P1_SCORE;
          }
          

          
        game_fsm.NOT_ISP1_CMP: // similar to NOT_ISP1 state 
          alufn = b1011 ; // NOT_ISP1
          asel = b00; //pass register ra value
          ra = b0110 ; // isP1 register
          
          rc=  b0110;// store result in isP1
          we = 1;
          
          game_fsm.d = game_fsm.TURN_LED_OFF;          
            

        game_fsm.TURN_LED_OFF:
          green_led = b0; 
          red_led = b0; 
          game_fsm.d = game_fsm.IDLE;
          
        
        game_ fsm.INCREMENT_P1_SCORE: //increments P1 score
          alufn =  6b000000 //ADDC
          asel = b00; //passes register ra 
          bsel = b010; //SEXT(1)
          ra= b0011 //p1score register
                 
          rc = b0011; //write to p1score register   
          we = b1;

          //split_choice = b0011; 
          //split_yes = b1;

          game_fsm.d = game_fsm.INCREMENT_P1_SCORE_SEG;


        game_fsm.INCREMENT_P1_SCORE_SEG: 
          alufn = b0011  //Just X 
          asel = b00; //passes register ra 
          ra = b0011 ; //p1 score register 
          rc =   b1010 ; //literal register
          we = 1;
          split_yes = 1 ;

          game_fsm.d = game_fsm.INCREMENT_P2_SCORE;   


        




        game_ fsm.INCREMENT_P2_SCORE: //increments P1 score
          alufn =  6b000000 //ADDC
          asel = b00; //passes register ra 
          bsel = b010; //SEXT(1)
          ra= b0100 ; //p2score register
                 
          rc = b0100; //write to p2score register   
          we = 1;
         // split_choice = b0100; 
        //  split_yes= b1;

            game_fsm.d = game_fsm.INCREMENT_P2_SCORE_SEG;
          
          ;


        game_fsm.INCREMENT_P2_SCORE_SEG: 
          alufn = b0011  //Just X 
          asel = b00; //passes register ra 
          ra = b0100 ; //p1 score register 
          rc =   b1010 ; //literal register
          we = 1;
          split_yes = 1 ;

          game_fsm.d = game_fsm.INCREMENT_ROUND;   



        game_fsm.CMPEQ_ISP1_0:   //comparing isP1 0 
          alufn = 6b110010; // COMPEQ
          asel = b00;  //passing ra register
          bsel=  b001; //passing SEXT(0)
          ra = b0110 ; 
         
          rc = b0111; //store to temp register 1 
          we =1;
          if(rc.q == 1){
            game_fsm.d = game_fsm.INCREMENT_P1_SCORE_CMP;
          }
          else {
            game_fsm.d = game_fsm.INCREMENT_P2_SCORE_CMP;

          }



        game_ fsm.INCREMENT_P1_SCORE_CMP: //increments P1 score
          alufn =  6b000000 //ADDC
          asel = b00; //passes register ra 
          bsel = b010; //SEXT(1)
          ra= b0011; //p1score register
                 
          rc = b0011; //write to p1score register   
          we = b1;
       //   split_choice = b0011;

         // split_yes = b1;
          game_fsm.d = game_fsm.INCREMENT_P1_SCORE_CMP_SEG;



          
        game_fsm.INCREMENT_P1_SCORE_CMP_SEG:  //display to 7 seg
          alufn = b0011  //Just X 
          asel = b00; //passes register ra 
          ra = b0011 ; //p1 score register 
          rc =   b1010 ; //literal register
          we = 1;
          split_yes = 1 ;

          game_fsm.d = game_fsm.INCREMENT_ROUND;



        game_ fsm.INCREMENT_P2_SCORE_CMP: //increments P1 score
          alufn =  6b000000 //ADDC
          asel = b00; //passes register ra 
          bsel = b010; //SEXT(1)
          ra= b0100 ; //p2score register
                 
          rc = b0100; //write to p2score register   
          we = 1;
       //   split_choice = b0100; 
          split_yes = b1;
          
          game_fsm.d = game_fsm.INCREMENT_P2_SCORE_CMP_SEG;


        game_fsm.INCREMENT_P2_SCORE_CMP_SEG: 
          alufn = b0011  //Just X 
          asel = b00; //passes register ra 
          ra = b0100; //p2 score register 
          rc =   b1010 ; //literal register
          we = 1;
          split_yes = 1 ;

          game_fsm.d = game_fsm.INCREMENT_ROUND;

        game_fsm.INCREMENT_ROUND: //incrementing round
          alufn = 6b000000 ; //ADDC
          asel = b00 ; //register ra
          bsel = b010 ; //SEXT(1)

          ra= b0101 ;
          rc= b0101; //round register
       //   split_choice =  b0101; 
         // split_yes = b1;
          we=1;
          game_fsm.d = game_fsm.INCREMENT_ROUND_SEG;


          
        game_fsm.INCREMENT_ROUND_SEG: 
          alufn = b0011  //Just X 
          asel = b00; //passes register ra 
          ra = b0101; //round  register 
          rc =   b1010 ; //literal register
          we = 1;
          split_yes = 1 ;

          game_fsm.d = game_fsm.CMPLEQC_ROUND_5;

          

        game_fsm.CMPLEQC_ROUND_5:
            alufn = b110110; 
            asel = b00 ; //passing ra register
            bsel =  b011;  //  passing SEXT(5)
            ra= b0101 ; // register that stores round
            
            rc=  b0111; // stored in temp register 1
            we =  1; 
            if(rc.q == 1){ 
                game_fsm.d = game_fsm.RESET_SEQUENCE_COUNT;

            }
            else {
                game_fsm.d = game_fsm.CMPLEQ_P1_SCORE_P2SCORE;
            }


        game_fsm.RESET_SEQUENCE_COUNT:
            alufn = b000000;
            asel = b00; 
            bsel = b001 ; //SEXT(0)  
            ra=  b0010; //stores sequence count 
            
            rc = b0010;  //writeback to sequence count
            we=1; 

            game_fsm.d = game_fsm.TURN_LED_OFF1;


        game_fsm.TURN_LED_OFF1:
            green_led = b0;
            red_led = b0;
            game_fsm.d = game_fsm.SET_ISP1_1;

        game_fsm.SET_ISP1_1: 
            alufn = b0100; //"JUST y
            bsel = b010; // passes SEXT(1) 
              
            
            rc = b0110  ;  //writes 1 to isp1 reg
            we=1; 

            game_fsm.d = game_fsm.IDLE;



        game_fsm.CMPLEQ_P1_SCORE_P2SCORE:
            alufn = 6b110110;
            asel = b00; //passes ra register
            bsel = b000; //passes rb register
            ra= b0011;  //p1 score
            rb = b0100;  //p2 score
            rc = b0111; //stored in temp register 1

            we = 1 ;             
            if(rc.q==1){
                game_fsm.d = game_fsm.P2_WINNER;

            }

            else {
                game_fsm.d = game_fsm.CMPEQ_P1_SCORE_P2SCORE;
            }

        game_fsm.CMPEQ_P1_SCORE_P2SCORE:
            alufn= 6b110010;
            asel = b00; //pass ra register
            bsel = b000;  //pass rb register 
            ra =   b0011; // p1 score
            rb =  b0100; //p2 score 
            rc =  b1000; //store in temp register 2
            we = 1;
            if(rc.q==1){
                game_fsm.d = game_fsm.TIE;

            }

            else {
                game_fsm.d = game_fsm.P1_WINNER;

            }


        game_fsm.P1_WINNER: 
          
          alufn = b0011  //Just X 
          asel = b00; //passes register ra 
          ra = b0011 ; //p1score register 
          rc =   b1010 ; //literal register
          we = 1;
          split_yes = 1 ;

          

          game_fsm.d= game_fsm.END; 

        game_fsm.P2_WINNER: 
          alufn = b0011;  //Just X 
          asel = b00; //passes register ra 
          ra = b0100 ; //p1score register 
          rc = b1010 ; //literal register
          we = 1;
          split_yes = 1 ;

          

          game_fsm.d= game_fsm.END; 

        game_fsm.TIE: 
          alufn = b0100:;  //Just Y
          bsel = b101;
          rc = b1010 ; 
          split_yes = 1; 
          we = 1; 

        

            game_fsm.d= game_fsm.END; 

        game_fsm.END: 
            split_yes = b0;
            green_led = b0;
            red_led = b0;
            
            game_fsm.d= game_fsm.START;





        default: //default value assigns the state to START of the game
          game_fsm.d = game_fsm.START;
          
      }
  
}

        





        




