module game_miniRegfile ( //regfile has two read ports and one write port
    input clk,  // clock
    input rst,  // reset
    input write_address[4], // write address for port c
    input we, // write enable
    input data[16], // data in for port c
    
    
    input read_address_a[4], //address port a 
    input read_address_b[4], //address port b
    output out_a[16], //read port a
    output out_b[16] //read port b
  ) {  
  
  .clk(clk){
    .rst(rst){
      dff pattern[9][16];
      dff lvl_count[16];  //store the current level number (1 to 9)
      dff seq_count[16];  //store the number of pattern (1 to 9)
      dff gen_disp_state[16]; //store a boolean whether pattern is being displayed or not
      dff timer_store[16];  //store number representing time left in countdown
      dff temp_var[3][16]; //store the input from user (to be compared to number in seq_store)
    }
  }
  
  always {   
    
     //read port a
    case(read_address_a){
        b0000 : out_a = pattern.q[0]; //first pattern
        b0001 : out_a = pattern.q[1]; //second pattern
        b0010 : out_a = pattern.q[2]; //third pattern
        b0011 : out_a = pattern.q[3]; //fourth pattern
        b0100 : out_a = pattern.q[4]; //fifth pattern
        b0101 : out_a = pattern.q[5]; //sixth pattern
        b0110 : out_a = pattern.q[6]; //seventh pattern
        b0111 : out_a = pattern.q[7]; //eighth pattern
        b1000 : out_a = pattern.q[8]; //ninth pattern
        b1001 : out_a = lvl_count.q;
        b1010 : out_a = seq_count.q;
        b1011 : out_a = gen_disp_state.q;
        b1100 : out_a = timer_store.q;
        b1101 : out_a = temp_var.q[0]; //temporary registers
        b1110 : out_a = temp_var.q[1];
        b1111 : out_a = temp_var.q[2]; 
        default: out_a = 0;
    }
    
    //read port b
    case(read_address_b){
        b0000 : out_b = pattern.q[0]; //first pattern
        b0001 : out_b = pattern.q[1]; //second pattern
        b0010 : out_b = pattern.q[2]; //third pattern
        b0011 : out_b = pattern.q[3]; //fourth pattern
        b0100 : out_b = pattern.q[4]; //fifth pattern
        b0101 : out_b = pattern.q[5]; //sixth pattern
        b0110 : out_b = pattern.q[6]; //seventh pattern
        b0111 : out_b = pattern.q[7]; //eighth pattern
        b1000 : out_b = pattern.q[8]; //ninth pattern
        b1001 : out_b = lvl_count.q;
        b1010 : out_b = seq_count.q;
        b1011 : out_b = gen_disp_state.q;
        b1100 : out_b = timer_store.q;
        b1101 : out_b = temp_var.q[0]; //temporary registers
        b1110 : out_b = temp_var.q[1];
        b1111 : out_b = temp_var.q[2]; 
        default : out_b = 0;
    }
    
         //write port
    if (we){
      case(write_address){
        b0000 : pattern.d[0] = data; //first pattern
        b0001 : pattern.d[1] = data; //second pattern
        b0010 : pattern.d[2] = data; //third pattern
        b0011 : pattern.d[3] = data; //fourth pattern
        b0100 : pattern.d[4] = data; //fifth pattern
        b0101 : pattern.d[5] = data; //sixth pattern
        b0110 : pattern.d[6] = data; //seventh pattern
        b0111 : pattern.d[7] = data; //eighth pattern
        b1000 : pattern.d[8] = data; //ninth pattern
        b1001 : lvl_count.d = data; 
        b1010 : seq_count.d = data;
        b1011 : gen_disp_state.d =data;
        b1100 : timer_store.d = data;
        b1101 : temp_var.d[0] = data; //temporary registers
        b1110 : temp_var.d[1] = data;
        b1111 : temp_var.d[2] = data;
      }
    }    
  }
}