/*
   This file was generated automatically by Alchitry Labs version 1.2.7.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module alu_16_3 (
    input [15:0] x,
    input [15:0] y,
    input [5:0] alufn,
    output reg [15:0] out,
    output reg z,
    output reg v,
    output reg n
  );
  
  
  
  wire [16-1:0] M_arith_arithOut;
  wire [1-1:0] M_arith_z;
  wire [1-1:0] M_arith_v;
  wire [1-1:0] M_arith_n;
  reg [16-1:0] M_arith_x;
  reg [16-1:0] M_arith_y;
  reg [2-1:0] M_arith_arithAlufn;
  arith_16_7 arith (
    .x(M_arith_x),
    .y(M_arith_y),
    .arithAlufn(M_arith_arithAlufn),
    .arithOut(M_arith_arithOut),
    .z(M_arith_z),
    .v(M_arith_v),
    .n(M_arith_n)
  );
  
  wire [16-1:0] M_arithForComp_arithOut;
  wire [1-1:0] M_arithForComp_z;
  wire [1-1:0] M_arithForComp_v;
  wire [1-1:0] M_arithForComp_n;
  reg [16-1:0] M_arithForComp_x;
  reg [16-1:0] M_arithForComp_y;
  reg [2-1:0] M_arithForComp_arithAlufn;
  arith_16_7 arithForComp (
    .x(M_arithForComp_x),
    .y(M_arithForComp_y),
    .arithAlufn(M_arithForComp_arithAlufn),
    .arithOut(M_arithForComp_arithOut),
    .z(M_arithForComp_z),
    .v(M_arithForComp_v),
    .n(M_arithForComp_n)
  );
  
  wire [16-1:0] M_bool_boolOut;
  reg [16-1:0] M_bool_x;
  reg [16-1:0] M_bool_y;
  reg [4-1:0] M_bool_boolAlufn;
  bool_16_8 bool (
    .x(M_bool_x),
    .y(M_bool_y),
    .boolAlufn(M_bool_boolAlufn),
    .boolOut(M_bool_boolOut)
  );
  
  wire [16-1:0] M_shift_shiftOut;
  reg [16-1:0] M_shift_x;
  reg [16-1:0] M_shift_y;
  reg [2-1:0] M_shift_shiftAlufn;
  shift_16_9 shift (
    .x(M_shift_x),
    .y(M_shift_y),
    .shiftAlufn(M_shift_shiftAlufn),
    .shiftOut(M_shift_shiftOut)
  );
  
  wire [16-1:0] M_comp_compOut;
  reg [1-1:0] M_comp_z;
  reg [1-1:0] M_comp_v;
  reg [1-1:0] M_comp_n;
  reg [2-1:0] M_comp_compAlufn;
  comp_16_10 comp (
    .z(M_comp_z),
    .v(M_comp_v),
    .n(M_comp_n),
    .compAlufn(M_comp_compAlufn),
    .compOut(M_comp_compOut)
  );
  
  always @* begin
    M_arith_x = x;
    M_arith_y = y;
    M_arith_arithAlufn = alufn[0+1-:2];
    z = M_arith_z;
    v = M_arith_v;
    n = M_arith_n;
    M_arithForComp_x = x;
    M_arithForComp_y = y;
    M_arithForComp_arithAlufn = 2'h1;
    M_comp_z = M_arithForComp_z;
    M_comp_v = M_arithForComp_v;
    M_comp_n = M_arithForComp_n;
    M_comp_compAlufn = alufn[1+1-:2];
    M_bool_x = x;
    M_bool_y = y;
    M_bool_boolAlufn = alufn[0+3-:4];
    M_shift_x = x;
    M_shift_y = y;
    M_shift_shiftAlufn = alufn[0+1-:2];
    
    case (alufn[4+1-:2])
      2'h0: begin
        out = M_arith_arithOut;
      end
      2'h1: begin
        out = M_bool_boolOut;
      end
      2'h2: begin
        out = M_shift_shiftOut;
      end
      2'h3: begin
        out = M_comp_compOut;
      end
      default: begin
        out = 16'h0000;
      end
    endcase
  end
endmodule
